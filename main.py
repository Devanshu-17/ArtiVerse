from flask import Flask, render_template, request, jsonify
from dotenv import load_dotenv
import os
from langchain.chat_models import ChatOpenAI
from langchain.chains import ConversationChain
from langchain.memory import ConversationEntityMemory
from langchain.memory.prompt import ENTITY_MEMORY_CONVERSATION_TEMPLATE
import requests
import base64

load_dotenv()

app = Flask(__name__, template_folder='./templates', static_folder='./static')

if os.getenv("OPENAI_API_KEY") is None or os.getenv("OPENAI_API_KEY") == "":
    print("OPENAI_API_KEY is not set. Please add your key to .env")
else:
    print("OPENAI_API_KEY set.")

if os.getenv("STABILITY_API_KEY") is None or os.getenv("STABILITY_API_KEY") == "":
    print("STABILITY_API_KEY is not set. Please add your key to .env")
else:
    print("STABILITY_API_KEY set.")

llm = ChatOpenAI(request_timeout=600)
conversation = ConversationChain(
    llm=llm,
    memory=ConversationEntityMemory(llm=llm),
    prompt=ENTITY_MEMORY_CONVERSATION_TEMPLATE,
    verbose=False
)

engine_id = "stable-diffusion-xl-beta-v2-2-2"
api_host = os.getenv('API_HOST', 'https://api.stability.ai')
api_key = os.getenv("STABILITY_API_KEY")

if api_key is None:
    raise Exception("Missing Stability API key.")

@app.route("/")
def home():
    """
    Render the Home template.

    Returns:
        str: Rendered HTML template for the home page.
    """
    return render_template('index.html')

@app.route("/demo")
def demo():
    """
    Render the demo template.

    Returns:
        str: Rendered HTML template for the demo page. It contains the chat UI.
    """
    return render_template('demo.html')

@app.route("/product")
def product():
    """
    Render the product template.

    Returns:
        str: Rendered HTML template for the Chat product page. It contains the products UI.
    """
    return render_template('product.html')

@app.route("/product2")
def product2():
    """
    Render the product template.

    Returns:
        str: Rendered HTML template for the Image Generation product page. It contains the products UI.
    """
    return render_template('product2.html')


# Define a custom b64encode filter
def b64encode_filter(data):
    return base64.b64encode(data).decode("utf-8")

# Register the custom filter with Jinja2
app.jinja_env.filters["b64encode"] = b64encode_filter


@app.route("/generate", methods=["GET", "POST"])
def generate_image():
    """
    Handle the generation of the image based on user input.

    Returns:
        str: Rendered HTML template for the generated image.
    """
    if request.method == "POST":
        prompt = request.form.get("prompt")
        cfg_scale = int(request.form.get("cfg_scale"))
        clip_guidance_preset = request.form.get("clip_guidance_preset")
        height = int(request.form.get("height"))
        width = int(request.form.get("width"))
        samples = int(request.form.get("samples"))
        steps = int(request.form.get("steps"))

        response = requests.post(
            f"{api_host}/v1/generation/{engine_id}/text-to-image",
            headers={
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": f"Bearer {api_key}"
            },
            json={
                "text_prompts": [
                    {
                        "text": prompt
                    }
                ],
                "cfg_scale": cfg_scale,
                "clip_guidance_preset": clip_guidance_preset,
                "height": height,
                "width": width,
                "samples": samples,
                "steps": steps,
            },
        )

        if response.status_code != 200:
            raise Exception("Non-200 response: " + str(response.text))

        data = response.json()

        images = []
        for i, image in enumerate(data["artifacts"]):
            image_data = base64.b64decode(image["base64"])
            images.append(image_data)

        return render_template('generate.html', images=images)

    return render_template('generate.html')

@app.route("/get", methods=["GET", "POST"])
def chat():
    """
    Handle the chat interaction.

    Returns:
        dict: JSON response containing the chat response.
    """
    msg = request.form["msg"]
    response = get_chat_response(msg)
    return jsonify({'response': response})

def get_chat_response(text):
    """
    Get the chat response using ConversationChain.

    Args:
        text (str): Input text for the chat.

    Returns:
        str: Chat response generated by the ConversationChain.
    """
    ai_response = conversation.predict(input=text)
    return ai_response

if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0", port=int(os.environ.get("PORT", 8080)))
